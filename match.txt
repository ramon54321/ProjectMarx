

// Produce only if there is demand
// Fvoribility takes into account cost of other commodities such as production


// Favourability factors
//  - profit after raw material costs
//  - need for commodity in inventory
//  - market price is favourable


// How many times the expenses would the profit be (One value for all commodities)
profitFactor = (sellCommoditiesPrice - buyRawCommoditiesPrice) / sellCommoditiesPrice

// Alter asking price
// Making money
if (profitFactor > 0) {
  // Small chance to increase price of ask
  maybe => sellCommoditiesPrice * 1.01
}

// Losing money
else if (profitFactor < 0) {
  // Increase price of ask
  sellCommoditiesPrice * 1.04
}

// How many times of ideal do we have in inventory: Poisitive when should bid, negative when should ask
inventoryFactor = (idealInventory - inventory) / idealInventory

// Balance of opinionPrice to marketPrice: -1 when marketPrice is double the opinionPrice, 0 when same, 1 when marketPrice is 0
marketFactor = (opinionPrice - marketPrice) / opinionPrice

// Positive when good to bid, negative when good to ask
if (processCommodity) {
  favourability = (profitFactor + inventoryFactor + marketFactor) / 3
} else {
  favourability = (0 + inventoryFactor + marketFactor) / 3
}





// p = (100 - 60) / 100 = 0.4 // I can sell for 100 and it will cost me 60 to make, so factor is 0.4

// // For each commodity
//   i = (10 - 4) / 10 = 0.6 // Should have 10, only have 4, so factor is 0.6
//   m = (100 - 80) / 100 = 0.2 // I value it at 100, it is only 80, so factor is 0.2

//   // Is this commodity used while making goods
//   if (processCommodity) {
//     f = (i + m + p) / 3
//   }
//   // This commodity is not used while making goods
//   else {
//     f = (i + m + 0) / 3
//   }

















tickCount++
tickPopulation
agents.tickFavorability
agents.tickProduction
agents.tickOffers
agents.tickTax
auctionHouse.tickMarket
renderer.tick









tickTax(world: World) {
  this.currency -= 2
  world.reserveBank += 2
}

produce(world: World) {
  
}
calculateDesired(auctionHouse: AuctionHouse) {
  
}
placeOffers(auctionHouse: AuctionHouse) {
  
}
accept(offerResolution: OfferResolution) {
  
}
reject(offer: Offer) {
  
}

this.tickCount++
    this.spawn()
    this.agents.forEach(agent => agent.produce(this))
    this.agents.forEach(agent => agent.calculateDesired(this.auctionHouse))
    this.agents.forEach(agent => agent.placeOffers(this.auctionHouse))
    this.auctionHouse.calculateMarketAverages()
    this.calculateMarketData()
    this.renderer.tick()
    this.updateUI()
    this.updateCharts()
    this.auctionHouse.resolveOffers()
    this.agents.forEach(agent => agent.tickTax(this))
    this.agents.forEach(agent => {
      if (agent.currency <= 0) {
        const index = this.agents.indexOf(agent);
        if (index > -1) {
          this.agents.splice(index, 1)
          // const professionString = PROFESSIONS_STRING.reduce((best, proStr) => {
          //   const avgCurrency = this.totalCurrency[proStr] / this.agentTypeCount[proStr]
          //   if (avgCurrency > best.currency) {
          //     return {
          //       currency: avgCurrency,
          //       proStr
          //     }
          //   } else {
          //     return best
          //   }
          // }, {
          //   currency: 0,
          //   proStr: ""
          // }).proStr
          // if (Math.random() < 0.5) {
          //   this.agents.unshift(new PROFESSIONS[PROFESSIONS_STRING.indexOf(professionString)](this.auctionHouse))
          // }
          this.agents.unshift(new PROFESSIONS[Math.floor(Math.random() * PROFESSIONS.length)](this.auctionHouse))
        } else {
          console.log("Cant find agent in list")
        }
      }




      import { Maybe } from 'tsmonad'

      interface Person {
        age: Maybe<number>
      }
      
      const bob: Person = {
        age: Maybe.just(21),
      }
      
      const rideStatus = bob.age
        .caseOf({
          just: age => age <= 15 ? "Free Pass" : "Normal Fare",
          nothing: () => "Unknown",
        })
      
      console.log(rideStatus)